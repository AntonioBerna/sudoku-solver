{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"sudoku-solver","text":"<p>This repository contains a C program that solves Sudoku puzzles using bitmasking + backtracking and dancing links techniques. The program is designed to efficiently handle Sudoku problems by representing the possible numbers for each cell as bitmasks, allowing for quick checks and updates during the solving process.</p> <p>You can explore the documentation following usage, algorithms and benchmarks sections.</p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#classic-way","title":"Classic way","text":"<p>If you want to try my code you need to clone the repository using the command:</p> <pre><code>git clone https://github.com/AntonioBerna/sudoku-solver.git\n</code></pre> <p>Now you can use the <code>make</code> command to generate the executable called <code>sudoku</code>, inside <code>bin/</code> directory, and then you will need to use the <code>./bin/sudoku &lt;problem number&gt;</code> command to run the program, where <code>&lt;problem number&gt;</code> is a number between 1 and 9 (depending on the Sudoku to be solved in <code>include/problems.h</code> file). For example, the command <code>./bin/sudoku 3</code> generates the following output:</p> <pre><code>-------------------------\n| 4 9 6 | 1 7 3 | 8 2 5 | \n| 2 7 8 | 5 9 6 | 4 1 3 | \n| 3 1 5 | 8 4 2 | 6 7 9 | \n-------------------------\n| 9 8 1 | 3 5 7 | 2 6 4 | \n| 5 4 3 | 2 6 8 | 1 9 7 | \n| 6 2 7 | 9 1 4 | 3 5 8 | \n-------------------------\n| 1 6 4 | 7 3 5 | 9 8 2 | \n| 7 3 2 | 6 8 9 | 5 4 1 | \n| 8 5 9 | 4 2 1 | 7 3 6 | \n-------------------------\nmain return value: 0\n</code></pre> <p>If you want to add more sudoku you will have to fix the code present in the <code>include/problems.h</code> file (adding new matrices) and also the <code>NO_PROBLEMS</code> macro present in the <code>include/settings.h</code> file. Please don't forget to update the following sudoku matrix (present at the bottom of the <code>include/problems.h</code> file):</p> <pre><code>static unsigned char (*problems[NO_PROBLEMS + 1])[SIZE][SIZE] = {\n    NULL,\n    &amp;problem1, &amp;problem2, &amp;problem3,\n    &amp;problem4, &amp;problem5, &amp;problem6,\n    &amp;problem7, &amp;problem8, &amp;problem9\n};\n</code></pre> <p>Finally, if you want to remove the executable and object files, you can use the <code>make clean</code> command.</p> <p>That's it!</p>"},{"location":"usage/#docker-way","title":"Docker way","text":"<p>Another solution is to download my docker image from the <code>Docker Hub</code> registry using the following command:</p> <pre><code>docker pull antonioberna/sudoku-solver\n</code></pre> <p>Now you can run the container using the following command:</p> <pre><code>docker run --rm antonioberna/sudoku-solver 3\n</code></pre> <p>Note</p> <p>The command above will solve the third Sudoku present in the <code>include/problems.h</code> file. If you want to solve another Sudoku, just change the number <code>3</code> to another number between 1 and 9.</p> <p>Finally, if you want to remove the image from your machine, you can use the <code>docker rmi antonioberna/sudoku-solver</code> command.</p>"},{"location":"algorithms/bitmasking-backtracking/","title":"Bitmasking + Backtracking Algorithm","text":"<p>My algorithm solves Sudoku using bitmasking, a technique that allows you to represent sets of numbers by bits in an integer. The basic idea is to represent which numbers (from 1 to 9) are still available for each row, column and 3x3 block of the Sudoku, using bitmasks. Let's see step by step how it works.</p>"},{"location":"algorithms/bitmasking-backtracking/#bitmasking","title":"Bitmasking","text":"<p>The algorithm uses an array <code>mask[HALF_SIZE][SIZE]</code>, where:</p> <ul> <li><code>mask[0][...]</code> keeps track of the numbers already present per row,</li> <li><code>mask[1][...]</code> keeps track of the numbers present per column,</li> <li><code>mask[2][...]</code> keeps track of the numbers in each 3x3 block.</li> </ul> <p>Each mask is a 16-bit integer (<code>uint16_t</code>), where the bits represent whether or not a number exists in the row/column/block.</p> <p>Note</p> <p>For example, if <code>mask[0][i] = 0b100000000</code> (in binary), it means that the number 9 is present in row <code>i</code> (bit 9 is set to 1).</p>"},{"location":"algorithms/bitmasking-backtracking/#bit-manipulation-functions","title":"Bit manipulation functions","text":"<pre><code>void set_bit(uint16_t mask[HALF_SIZE][SIZE], uint16_t i, uint16_t j, uint16_t bit_position) {\n    uint16_t bit_on = 1 &lt;&lt; bit_position;\n\n    // ? Set the corresponding bit in the row\n    mask[0][i] |= bit_on;\n\n    // ? Set the corresponding bit in the column\n    mask[1][j] |= bit_on;\n\n    // ? Set the corresponding bit in the 3x3 block\n    mask[2][COL_DISPLACEMENT(i, j)] |= bit_on;\n}\n</code></pre> <p>The <code>set_bit()</code> function sets the bit corresponding to the presence of a number (from 1 to 9) in the mask. For example, if we enter the number <code>k</code> in a Sudoku cell, the bit <code>k</code> of the mask corresponding to the row, column and block is set to 1. This is done using the shift <code>1 &lt;&lt; bit_position</code> operation which moves bit 1 to the corresponding position.</p> <pre><code>void clear_bit(uint16_t mask[HALF_SIZE][SIZE], uint16_t i, uint16_t j, uint16_t bit_position) {\n    uint16_t bit_off = ~(1 &lt;&lt; bit_position);\n\n    // ? Clears the corresponding bit in the row\n    mask[0][i] &amp;= bit_off;\n\n    // ? Clears the corresponding bit in the column\n    mask[1][j] &amp;= bit_off;\n\n    // ? Clears the corresponding bit in the 3x3 block\n    mask[2][COL_DISPLACEMENT(i, j)] &amp;= bit_off;\n}\n</code></pre> <p>while the <code>clear_bit()</code> function does the opposite: when we remove a number from a cell, the corresponding bit is cleared with <code>&amp;= ~(1 &lt;&lt; bit_position)</code>.</p>"},{"location":"algorithms/bitmasking-backtracking/#calculating-the-set-of-available-numbers","title":"Calculating the set of available numbers","text":"<p>When the algorithm needs to decide which number to insert into an empty cell, it computes the set of numbers already present in the row, column, and block of the cell. This is done using a bitwise OR operation:</p> <pre><code>// ? Calculate the set of possible numbers for the cell (row, column, block)\nset = mask[0][i] | mask[1][j] | mask[2][COL_DISPLACEMENT(i, j)];\n</code></pre> <p>The OR operation combines the bits set in the three masks: row, column and block, resulting in a set representing the numbers already occupied in that position.</p>"},{"location":"algorithms/bitmasking-backtracking/#calculating-the-possible-options","title":"Calculating the possible options","text":"<p>To figure out how many numbers are still available (i.e. how many bits are 0 in the set), use the <code>get_no_zeros()</code> function:</p> <pre><code>// ? This function counts the number of zeros in the binary representation of the set\nuint16_t get_no_zeros(uint16_t set) {\n    uint16_t count = 0;\n    for (uint16_t i = 1; i &lt;= SIZE; ++i) if ((set &amp; (1 &lt;&lt; i)) == 0) ++count;\n    return count;\n}\n</code></pre> <p>Here, the algorithm cycles through the bits from position 1 to 9 and counts how many bits are still 0, i.e. how many numbers can be inserted into the cell.</p>"},{"location":"algorithms/bitmasking-backtracking/#search-for-the-best-candidate","title":"Search for the best candidate","text":"<p>The algorithm explores all the empty cells and looks for the one with the least number of available options, since this reduces the number of attempts. This is done with the following code:</p> <pre><code>if ((*problem)[i][j] == 0) {\n\n    // ? Calculate the set of possible numbers for the cell (row, column, block)\n    set = mask[0][i] | mask[1][j] | mask[2][COL_DISPLACEMENT(i, j)];\n\n    // ? Calculate the number of zeros in the set\n    size = get_no_zeros(set);\n\n    // ? If the set size is less than the minimum size found so far\n    if (size &lt; new_size) {\n        row = i;\n        col = j;\n        new_set = set;\n        new_size = size;\n\n        // ? If the set size is 0, the Sudoku is not solvable\n        // ? else if there is only one possible number, exit immediately\n        if (size == 0) return false;\n        else if (size == 1) goto end;\n    }\n}\n</code></pre> <p>Here we look for the cell with the smallest set of numbers (i.e. the one with the fewest options available).</p>"},{"location":"algorithms/bitmasking-backtracking/#backtracking","title":"Backtracking","text":"<p>Finally, the algorithm tries to insert every possible number (the 0 bits in the set) into the selected cell, then recursively calls the same function to solve the rest of the Sudoku:</p> <pre><code>// ? Iterates over the possible numbers (from 1 to 9) for the selected cell\nfor (uint16_t k = 1; k &lt;= SIZE; ++k) {\n\n    // ? If the number k is not present in the set of possible numbers\n    if ((new_set &amp; (1 &lt;&lt; k)) == 0) {\n\n        // ? Try assigning the number k to the cell\n        (*problem)[row][col] = k;\n        set_bit(mask, row, col, k);\n\n        // ? Recursive call to continue with the resolution\n        if (bit_operations(problem, mask)) return true; // ? if the recursive call returns true, the Sudoku is solved\n\n        // ? If the recursive call returns false, unassign the bits\n        clear_bit(mask, row, col, k);\n    }\n}\n</code></pre> <p>If recursion fails, the entered number is removed and another is tried. If no number works, the cell is reset to 0, and the process is backtracked.</p>"},{"location":"algorithms/bitmasking-backtracking/#solution","title":"Solution","text":"<p>If all cells are filled correctly without contradictions, the Sudoku is solved.</p> <pre><code>void solve(unsigned char (*problem)[SIZE][SIZE]) {\n    // ? Bitmask initialization\n    uint16_t mask[HALF_SIZE][SIZE] = { 0 };\n\n    // ? Setting the bits in the bitmask based on the numbers already present in the Sudoku\n    for (uint16_t i = 0; i &lt; SIZE; ++i) {\n        for (uint16_t j = 0; j &lt; SIZE; ++j) {\n            set_bit(mask, i, j, (*problem)[i][j]);\n        }\n    }\n\n    // ? Function call to solve Sudoku\n    if (!bit_operations(problem, mask)) puts(\"The Sudoku is not solvable.\");\n}\n</code></pre> <p>The <code>solve()</code> function initializes the masks based on the numbers already present and calls the recursive function <code>bit_operations()</code> to solve the Sudoku.</p>"},{"location":"algorithms/dancing-links/","title":"Dancing Links Algorithm","text":"<p>TODO...</p>"},{"location":"benchmarks/bitmasking-backtracking/","title":"Bitmasking + Backtracking Benchmarks","text":"<p>The following table shows the hardware and software specifications regarding my setup:</p> OS CPU RAM Toolchain Manjaro Linux v25.0.0 Intel Core i7-8650U 32GB DDR4 clang v19.1.7 <p>You can use <code>make test</code> command to generate the executable called <code>test</code>, inside <code>bin/</code> directory, and then you will need to use the <code>./bin/test</code> command to run the program. The output will be the following:</p> <pre><code>=================================\nProblem 1 solved in 13.064 \u03bcs.\nProblem 1 is valid.\n=================================\nProblem 2 solved in 4.071 \u03bcs.\nProblem 2 is valid.\n=================================\nProblem 3 solved in 531.553 \u03bcs.\nProblem 3 is valid.\n=================================\nProblem 4 solved in 23.155 \u03bcs.\nProblem 4 is valid.\n=================================\nProblem 5 solved in 8.589 \u03bcs.\nProblem 5 is valid.\n=================================\nProblem 6 solved in 9.722 \u03bcs.\nProblem 6 is valid.\n=================================\nProblem 7 solved in 17.542 \u03bcs.\nProblem 7 is valid.\n=================================\nProblem 8 solved in 19.684 \u03bcs.\nProblem 8 is valid.\n=================================\nProblem 9 solved in 10.520 \u03bcs.\nProblem 9 is valid.\n=================================\nTotal time: 637.900 \u03bcs.\n=================================\n</code></pre> <p>Note</p> <p>The <code>test</code> program generate the <code>test/sudoku_results.log</code> file with the results of the tests.</p>"},{"location":"benchmarks/dancing-links/","title":"Dancing Links Benchmarks","text":"<p>TODO...</p>"}]}